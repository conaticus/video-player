/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var api;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./api/classes/MediaPlayerManager.js":
/*!*******************************************!*\
  !*** ./api/classes/MediaPlayerManager.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const videoManager = __webpack_require__(/*! ./VideoManager */ \"./api/classes/VideoManager.js\");\r\nconst clearSurroundings = __webpack_require__(/*! ../functions/clearSurroundings */ \"./api/functions/clearSurroundings.js\");\r\nconst addKeyListeners = __webpack_require__(/*! ../functions/addKeyListeners */ \"./api/functions/addKeyListeners.js\");\r\nconst debug = __webpack_require__(/*! ../functions/debug */ \"./api/functions/debug.js\");\r\n\r\n/**\r\n * {@link MediaPlayerManager}\r\n * Class controlling the media player\r\n */\r\nclass MediaPlayerManager {\r\n    constructor() {\r\n        this.mediaPlayer = null;\r\n        this.menu = null;\r\n        this.hidden = false;\r\n        this.fullscreen = false;\r\n    }\r\n\r\n    /**\r\n     * Create the media player with the DOM\r\n     * @param {boolean=} clearElementsOnVideoLoad\r\n     * @returns {void}\r\n     */\r\n    create(clearElementsOnVideoLoad = true) {\r\n        this.mediaPlayer = document.createElement(\"div\");\r\n        const video = document.createElement(\"video\");\r\n\r\n        // For opacity change when pausing\r\n        this.mediaPlayer.backgroundColor = \"black\";\r\n\r\n        video.style.position = \"fixed\";\r\n        video.style.right = 0;\r\n        video.style.bottom = 0;\r\n        video.style.width = \"100%\";\r\n        video.style.height = \"100%\";\r\n\r\n        videoManager.video = video;\r\n        this.mediaPlayer.appendChild(video);\r\n\r\n        this.mediaPlayer.className = \"media-player\";\r\n        document.body.appendChild(this.mediaPlayer);\r\n\r\n        addEventListener(\r\n            \"videoload\",\r\n            () => {\r\n                if (clearElementsOnVideoLoad) {\r\n                    clearSurroundings(this.mediaPlayer);\r\n                }\r\n\r\n                this.loadVideoMenu();\r\n            },\r\n            {\r\n                once: true,\r\n            }\r\n        );\r\n\r\n        debug(\"Media player created.\");\r\n    }\r\n\r\n    /**\r\n     * Load the media player menu with the DOM\r\n     * @returns {void}\r\n     */\r\n    loadVideoMenu() {\r\n        this.menu = document.createElement(\"div\");\r\n        const durationBar = document.createElement(\"div\");\r\n\r\n        this.menu.style.display = \"none\";\r\n        this.menu.style.position = \"absolute\";\r\n        this.menu.style.bottom = 0;\r\n        this.menu.style.left = 0;\r\n        this.menu.style.width = \"100%\";\r\n        this.menu.style.height = \"3vw\";\r\n        this.menu.style.backgroundColor = \"black\";\r\n        this.menu.style.opacity = 0.8;\r\n        this.menu.style.fontSize = \"20px\";\r\n\r\n        durationBar.style.lineHeight = this.menu.style.height;\r\n        durationBar.style.margin = \"0px 20px\";\r\n\r\n        setInterval(() => {\r\n            // Check a video is loaded before setting the duration\r\n            if (!videoManager.videoLoaded) return;\r\n\r\n            const durationDate = new Date(0);\r\n            const currTimeDate = new Date(0);\r\n            durationDate.setSeconds(videoManager.video.duration);\r\n\r\n            currTimeDate.setSeconds(videoManager.video.currentTime);\r\n\r\n            const durationTimeString = durationDate.toISOString().substr(11, 8);\r\n            const currTimeString = currTimeDate.toISOString().substr(11, 8);\r\n\r\n            durationBar.innerText = `${currTimeString}/${durationTimeString}`;\r\n        }, 20);\r\n\r\n        this.menu.appendChild(durationBar);\r\n        this.mediaPlayer.appendChild(this.menu);\r\n\r\n        this.registerEvents();\r\n\r\n        debug(\"Video menu loaded.\");\r\n    }\r\n\r\n    /**\r\n     * Show media player menu\r\n     * @returns {void}\r\n     */\r\n    showVideoMenu() {\r\n        this.menu.style.display = \"block\";\r\n    }\r\n\r\n    /**\r\n     * Hide media player menu\r\n     * @returns {void}\r\n     */\r\n    hideVideoMenu() {\r\n        this.menu.style.display = \"none\";\r\n    }\r\n\r\n    /**\r\n     * Add event listeners\r\n     * @returns {void}\r\n     */\r\n    registerEvents() {\r\n        let previousMenuTimeout;\r\n\r\n        addEventListener(\"mousemove\", () => {\r\n            this.showVideoMenu();\r\n\r\n            if (previousMenuTimeout) clearTimeout(previousMenuTimeout);\r\n\r\n            previousMenuTimeout = setTimeout(() => {\r\n                this.hideVideoMenu();\r\n            }, 3000);\r\n        });\r\n\r\n        addEventListener(\"videointeract\", () => {\r\n            this.showVideoMenu();\r\n\r\n            if (previousMenuTimeout) clearTimeout(previousMenuTimeout);\r\n\r\n            previousMenuTimeout = setTimeout(() => {\r\n                this.hideVideoMenu();\r\n            }, 3000);\r\n        });\r\n\r\n        addKeyListeners([\r\n            [\"h\", () => this.toggleHide()],\r\n            [\"f\", () => this.toggleFullscreen()],\r\n        ]);\r\n\r\n        debug(\"Media player events registered.\");\r\n    }\r\n\r\n    /**\r\n     * Toggles fullscreen for the media player\r\n     * @returns {void}\r\n     */\r\n    toggleFullscreen() {\r\n        if (this.fullscreen) {\r\n            document.exitFullscreen();\r\n        } else {\r\n            this.mediaPlayer.requestFullscreen();\r\n        }\r\n\r\n        this.fullscreen = !this.fullscreen;\r\n\r\n        debug(\"Fullscreen toggled.\");\r\n    }\r\n\r\n    /**\r\n     * Hides/unhides the media player and pauses the currently loaded video\r\n     * @returns {void}\r\n     */\r\n    toggleHide() {\r\n        if (this.hidden) {\r\n            this.mediaPlayer.style.opacity = 1;\r\n            videoManager.video.pause();\r\n            this.hidden = false;\r\n        } else {\r\n            this.mediaPlayer.style.opacity = 0;\r\n            videoManager.video.pause();\r\n            this.hidden = true;\r\n        }\r\n\r\n        debug(\"Hide toggled.\");\r\n    }\r\n}\r\n\r\nconst mediaPlayerManager = new MediaPlayerManager();\r\nmodule.exports = mediaPlayerManager;\r\n\n\n//# sourceURL=webpack://api/./api/classes/MediaPlayerManager.js?");

/***/ }),

/***/ "./api/classes/SubtitleManager.js":
/*!****************************************!*\
  !*** ./api/classes/SubtitleManager.js ***!
  \****************************************/
/***/ ((module) => {

eval("/**\r\n * @see {@link SubtitleManager}\r\n * @see {@link https://docs.fileformat.com/video/srt}\r\n */\r\nclass SubtitleManager {\r\n    /**\r\n     * @param {string} raw - raw SRT subtitle string\r\n     * @returns {Object} Array of subtitle objects\r\n     */\r\n    parseSrt(raw) {\r\n        const subtitles = [];\r\n        const rawSubtitles = [];\r\n        let currRawSubtitle = [];\r\n\r\n        // Grab each section of subtitles from the raw string\\\r\n        // Would turn rawSubtitles into a 2d array\r\n        raw.split(\"\\n\").forEach((line) => {\r\n            if (line.trim() === \"\") {\r\n                rawSubtitles.push(currRawSubtitle);\r\n                currRawSubtitle = [];\r\n                return;\r\n            }\r\n\r\n            currRawSubtitle.push(line);\r\n        });\r\n\r\n        rawSubtitles.forEach((rawSubtitle) => {\r\n            const subtitle = {\r\n                number: null,\r\n                duration: {},\r\n                subtitle: null,\r\n            };\r\n\r\n            rawSubtitle.forEach((line, index) => {\r\n                if (index === SRT.SubtitleType.Number) {\r\n                    subtitle.number = parseInt(line);\r\n                } else if (index === SRT.SubtitleType.Duration) {\r\n                    const durations = line.split(\"-->\");\r\n                    subtitle.duration.start = this.parseDuration(durations[0]);\r\n                    subtitle.duration.end = this.parseDuration(durations[1]);\r\n                } else if (index === SRT.SubtitleType.Subtitle) {\r\n                    subtitle.subtitle = line.trim();\r\n                }\r\n            });\r\n\r\n            subtitles.push(subtitle);\r\n        });\r\n\r\n        return subtitles;\r\n    }\r\n\r\n    /**\r\n     * Example input: `01:50:48,500`\\\r\n     * Format full: `hours:minutes:seconds,milleseconds`\\\r\n     * Format min: `hh:mm:ss,mmm`\r\n     * @param {string} duration\r\n     * @returns {Object} parsed duration object\r\n     */\r\n    parseDuration(duration) {\r\n        const parsedDuration = {};\r\n\r\n        parsedDuration.hours = parseInt(duration[0] + duration[1]);\r\n        parsedDuration.minutes = parseInt(duration[3] + duration[4]);\r\n        parsedDuration.seconds = parseInt(duration[6] + duration[7]);\r\n        parsedDuration.milleseconds = parseInt(\r\n            duration[9] + duration[10] + duration[11]\r\n        );\r\n\r\n        return parsedDuration;\r\n    }\r\n}\r\n\r\nconst subtitleManager = new SubtitleManager();\r\nmodule.exports = subtitleManager;\r\n\n\n//# sourceURL=webpack://api/./api/classes/SubtitleManager.js?");

/***/ }),

/***/ "./api/classes/VideoManager.js":
/*!*************************************!*\
  !*** ./api/classes/VideoManager.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const addKeyListeners = __webpack_require__(/*! ../functions/addKeyListeners */ \"./api/functions/addKeyListeners.js\");\r\nconst { supportedExtensions } = __webpack_require__(/*! ../config */ \"./api/config.js\");\r\nconst debug = __webpack_require__(/*! ../functions/debug */ \"./api/functions/debug.js\");\r\n\r\n/**\r\n * Class managing the video element\r\n */\r\nclass VideoManager {\r\n    constructor() {\r\n        this.video = null;\r\n        this.videoLoaded = false;\r\n        this.eventsRegistered = false;\r\n        this.queue = [];\r\n        this.queuePostion = 0;\r\n        this.queueLoop = false;\r\n        this.loopCurrentVideo = false;\r\n    }\r\n\r\n    /**\r\n     * Open a video from file dialog\r\n     * @returns {void}\r\n     */\r\n    async openVideo() {\r\n        const dialogChoice = await ipcRequestDialog({\r\n            properties: [\"openFile\"],\r\n            filters: [\r\n                {\r\n                    name: \"Videos\",\r\n                    extensions: supportedExtensions,\r\n                },\r\n            ],\r\n        });\r\n\r\n        if (dialogChoice.canceled) return;\r\n\r\n        const src = dialogChoice.filePaths[0];\r\n        if (!this.video.src) this.video.src = src;\r\n\r\n        this.queue.push(src);\r\n        this.queueLoad(this.queuePostion);\r\n\r\n        debug(`Video '${src}' opened from dialog.`);\r\n    }\r\n\r\n    /**\r\n     * Gets the file dialog from the main process\\\r\n     * Changes the video src to the chosen file\r\n     * @returns {void}\r\n     */\r\n    async loadVideo(src) {\r\n        this.video.src = src;\r\n\r\n        // Ideally this should be executed somewhere else\r\n        this.video.onloadeddata = () => {\r\n            this.registerEvents();\r\n            this.videoLoaded = true;\r\n            this.play();\r\n            dispatchEvent(new Event(\"videoload\"));\r\n        };\r\n\r\n        debug(`Video '${src}' loaded.`);\r\n        document.title = \"\\u3053\\u306A\\u3053\\u306A\\u898B\\u308B - \" + src; // FIXME: hacky unicode characters for \"こなこな見る\" because windows didn't decode them correctly when changing the title.\r\n    }\r\n\r\n    /**\r\n     * Play the current video\r\n     * @returns {void}\r\n     */\r\n    play() {\r\n        this.video.play();\r\n        this.video.style.opacity = 1;\r\n\r\n        dispatchEvent(new Event(\"videointeract\"));\r\n\r\n        debug(\"Video playing.\");\r\n    }\r\n\r\n    /**\r\n     * Pause the current video\r\n     * @returns {void}\r\n     */\r\n    pause() {\r\n        this.video.pause();\r\n        this.video.style.opacity = 0.5;\r\n\r\n        dispatchEvent(new Event(\"videointeract\"));\r\n\r\n        debug(\"Video paused.\");\r\n    }\r\n\r\n    /**\r\n     * Play or pause the current video depending on if it is playing or not\r\n     * @returns {void}\r\n     */\r\n    togglePlay() {\r\n        if (this.video.paused) this.play();\r\n        else this.pause();\r\n    }\r\n\r\n    /**\r\n     * Skip the video forwards in seconds, default is 5 seconds\r\n     * @param {number} seconds\r\n     * @returns {void}\r\n     */\r\n    skipForward(seconds = 5) {\r\n        this.video.currentTime += seconds;\r\n        this.play();\r\n        dispatchEvent(new Event(\"videointeract\"));\r\n\r\n        debug(`Video skipped forward ${seconds} seconds.`);\r\n    }\r\n\r\n    /**\r\n     * Skip the video backwards in seconds, default is 5 seconds\r\n     * @param {number} seconds\r\n     * @returns {void}\r\n     */\r\n    skipBackward(seconds = 5) {\r\n        this.video.currentTime -= seconds;\r\n        this.play();\r\n        dispatchEvent(new Event(\"videointeract\"));\r\n\r\n        debug(`Video skipped backward ${seconds} seconds.`);\r\n    }\r\n\r\n    /**\r\n     * @returns {boolean} If at the end of the queue\r\n     */\r\n    get endOfQueue() {\r\n        return this.queuePostion === this.queue.length - 1;\r\n    }\r\n\r\n    /**\r\n     * @returns {boolean} If at the start of the queue\r\n     */\r\n    get startOfQueue() {\r\n        return this.queuePostion === 0;\r\n    }\r\n\r\n    /**\r\n     * Loads the next video in the queue\r\n     * @returns {void}\r\n     */\r\n    queueNext() {\r\n        if (this.loopCurrentVideo) {\r\n            this.video.currentTime = 0;\r\n            this.play();\r\n            return;\r\n        }\r\n\r\n        if (this.endOfQueue) {\r\n            if (this.queueLoop) this.queueStart();\r\n            return;\r\n        }\r\n\r\n        this.videoLoaded = false;\r\n        this.queuePostion++;\r\n        this.queueLoad(this.queuePostion);\r\n\r\n        debug(\"Next video in the queue loaded.\");\r\n    }\r\n\r\n    /**\r\n     * Loads the previous video in the queue\r\n     * @returns {void}\r\n     */\r\n    queuePrevious() {\r\n        if (this.startOfQueue) return;\r\n\r\n        this.videoLoaded = false;\r\n        this.queuePostion--;\r\n        this.queueLoad(this.queuePostion);\r\n\r\n        debug(\"Previous video in the queue loaded.\");\r\n    }\r\n\r\n    /**\r\n     * Goes to the start of the queue loop\r\n     * @returns {void}\r\n     */\r\n    queueStart() {\r\n        if (this.startOfQueue) {\r\n            this.video.currentTime = 0;\r\n            return;\r\n        }\r\n\r\n        this.videoLoaded = false;\r\n        this.queuePostion = 0;\r\n        this.queueLoad(this.queuePostion);\r\n\r\n        debug(\"First video in the queue loaded.\");\r\n    }\r\n\r\n    /**\r\n     * Loads a specific video in the queue\r\n     * @param {number} index\r\n     * @returns {void}\r\n     */\r\n    queueLoad(index) {\r\n        this.loadVideo(this.queue[index]);\r\n    }\r\n\r\n    /**\r\n     * Register events for the video manager\r\n     * Events are loaded here because we don't want some events firing before the video is loaded\r\n     * @returns {void}\r\n     */\r\n    registerEvents() {\r\n        if (this.eventsRegistered) return; // prevents events from being loaded twice when loading multiple videos\r\n\r\n        if (!this.video)\r\n            throw new Error(\"No video element found in the video manager.\");\r\n\r\n        this.video.onended = () => this.queueNext();\r\n\r\n        addKeyListeners([\r\n            [[\" \", \"p\"], () => this.togglePlay()],\r\n            [\"l\", () => this.skipForward()],\r\n            [\"j\", () => this.skipBackward()],\r\n            [\"m\", () => this.toggleMute()],\r\n            [\"n\", () => this.queueNext(), { requireControl: true }],\r\n            [\"p\", () => this.queuePrevious(), { requireControl: true }],\r\n            [\r\n                \"r\",\r\n                () => (this.queueLoop = !this.queueLoop),\r\n                { requireShift: true },\r\n            ],\r\n            [\r\n                \"l\",\r\n                () => (this.loopCurrentVideo = !this.loopCurrentVideo),\r\n                { requireShift: true },\r\n            ],\r\n        ]);\r\n\r\n        this.eventsRegistered = true;\r\n\r\n        debug(\"Video manager events registered.\");\r\n    }\r\n\r\n    /**\r\n     * Opens a specified folder and adds the videos in it to the queue\r\n     * @returns {void}\r\n     */\r\n    async openFolder() {\r\n        const dialogChoice = await ipcRequestDialog({\r\n            properties: [\"openDirectory\"],\r\n        });\r\n\r\n        if (dialogChoice.canceled) return;\r\n\r\n        const directoryPath = dialogChoice.filePaths[0];\r\n        const directoryContents = await fs.readdir(directoryPath, {\r\n            withFileTypes: true,\r\n        });\r\n\r\n        const videoFiles = this.filterVideoFiles(\r\n            directoryPath,\r\n            directoryContents\r\n        );\r\n        this.queue = videoFiles;\r\n        this.queuePostion = 0;\r\n        this.queueLoad(this.queuePostion);\r\n\r\n        debug(`Folder '${directoryPath}' loaded.`);\r\n    }\r\n\r\n    /**\r\n     * Gets all the supported videos in a directory\r\n     * @returns {string[]} Paths of all the videos\r\n     */\r\n    filterVideoFiles(dirPath, dirents) {\r\n        const filtered = dirents.filter((dirent) => {\r\n            let isVideoFile = false;\r\n\r\n            supportedExtensions.forEach((ext) => {\r\n                if (dirent.name.endsWith(ext)) isVideoFile = true;\r\n            });\r\n\r\n            return !dirent.isDirectory && isVideoFile;\r\n        });\r\n\r\n        const videoFiles = [];\r\n        filtered.forEach((dirent) =>\r\n            videoFiles.push(dirPath + \"/\" + dirent.name)\r\n        );\r\n\r\n        return videoFiles;\r\n    }\r\n\r\n    /**\r\n     * Mutes/unmutes the video\r\n     * @returns {void}\r\n     */\r\n    toggleMute() {\r\n        this.video.muted = !this.video.muted;\r\n\r\n        debug(\"Video mute toggled.\");\r\n    }\r\n}\r\n\r\nconst videoManager = new VideoManager();\r\nmodule.exports = videoManager;\r\n\n\n//# sourceURL=webpack://api/./api/classes/VideoManager.js?");

/***/ }),

/***/ "./api/config.js":
/*!***********************!*\
  !*** ./api/config.js ***!
  \***********************/
/***/ ((module) => {

eval("module.exports = {\r\n    supportedExtensions: [\"mp4\", \"mkv\", \"ogg\", \"webm\"],\r\n};\r\n\n\n//# sourceURL=webpack://api/./api/config.js?");

/***/ }),

/***/ "./api/functions/addKeyListeners.js":
/*!******************************************!*\
  !*** ./api/functions/addKeyListeners.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\r\n * Register a key event\r\n * @returns {void}\r\n */\r\nconst registerKeyEvent = (listener, { requireControl, requireShift }) => {\r\n    const [definedKey, callback] = listener;\r\n\r\n    addEventListener(\"keydown\", ({ key, ctrlKey, shiftKey }) => {\r\n        if (definedKey.toLowerCase() !== key) return;\r\n\r\n        if (requireControl && !shiftKey && ctrlKey) callback();\r\n        else if (requireShift && !ctrlKey && shiftKey) callback();\r\n        else if (requireShift && requireControl && ctrlKey && shiftKey)\r\n            callback();\r\n        else if (!ctrlKey && !shiftKey) callback();\r\n    });\r\n};\r\n\r\n/**\r\n * Register aliased key events\r\n * @returns {void}\r\n */\r\nconst registerKeyEvents = (listener, options) => {\r\n    const [keys, callback] = listener;\r\n\r\n    keys.forEach((_, idx) => {\r\n        registerKeyEvent([keys[idx], callback], options);\r\n    });\r\n};\r\n\r\n/**\r\n * Listen for key presses and run a function when pressed\r\n * @param {[string | string[], Function][]} keyListeners\r\n * @param {any} options\r\n * @returns {void}\r\n */\r\nconst addKeyListeners = (\r\n    keyListeners,\r\n    options = { requireControl: false, requireShift: false }\r\n) => {\r\n    keyListeners.forEach((listener) => {\r\n        const [keys] = listener;\r\n\r\n        if (typeof keys === \"string\") registerKeyEvent(listener, options);\r\n        else if (typeof keys === \"object\") registerKeyEvents(listener, options);\r\n    });\r\n};\r\n\r\nmodule.exports = addKeyListeners;\r\n\n\n//# sourceURL=webpack://api/./api/functions/addKeyListeners.js?");

/***/ }),

/***/ "./api/functions/clearSurroundings.js":
/*!********************************************!*\
  !*** ./api/functions/clearSurroundings.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const mediaPlayerManager = __webpack_require__(/*! ../classes/MediaPlayerManager */ \"./api/classes/MediaPlayerManager.js\");\r\n\r\n/**\r\n * Removes all body elements except for the media player\\\r\n * Returns a function that adds the elements back\r\n * @param {Object} mediaPlayer\r\n */\r\nconst clearSurroundings = (mediaPlayer = mediaPlayerManager.mediaPlayer) => {\r\n    if (!mediaPlayer)\r\n        throw new Error(\"No media player element found or provided.\");\r\n\r\n    // Remove all elements and add media player\r\n    document.body.textContent = \"\";\r\n    document.body.appendChild(mediaPlayer);\r\n};\r\n\r\nmodule.exports = clearSurroundings;\r\n\n\n//# sourceURL=webpack://api/./api/functions/clearSurroundings.js?");

/***/ }),

/***/ "./api/functions/debug.js":
/*!********************************!*\
  !*** ./api/functions/debug.js ***!
  \********************************/
/***/ ((module) => {

eval("/**\r\n * Logs debug output if in developer mode\r\n * This should have types if needed, in future\r\n * @param {string} message Debug message\r\n * @returns {void}\r\n */\r\nconst debug = (message) => {\r\n    if (!isDeveloperMode()) return;\r\n    console.log(`%c[DEBUG]: %c${message}`, \"color:#6493E1\", \"color:white\");\r\n};\r\n\r\nmodule.exports = debug;\r\n\n\n//# sourceURL=webpack://api/./api/functions/debug.js?");

/***/ }),

/***/ "./api/functions/registerKeyEvents.js":
/*!********************************************!*\
  !*** ./api/functions/registerKeyEvents.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const addKeyListeners = __webpack_require__(/*! ./addKeyListeners */ \"./api/functions/addKeyListeners.js\");\r\nconst videoManager = __webpack_require__(/*! ../classes/VideoManager */ \"./api/classes/VideoManager.js\");\r\n\r\n/**\r\n * Add all default key events\r\n * @returns {void}\r\n */\r\nconst registerKeyEvents = () => {\r\n    addKeyListeners([\r\n        [\"o\", () => videoManager.openVideo(), { requireControl: true }],\r\n        [\r\n            \"o\",\r\n            () => videoManager.openFolder(),\r\n            { requireControl: true, requireShift: true },\r\n        ],\r\n        [\"s\", () => ipcSettingsOpen()],\r\n    ]);\r\n};\r\n\r\nmodule.exports = registerKeyEvents;\r\n\n\n//# sourceURL=webpack://api/./api/functions/registerKeyEvents.js?");

/***/ }),

/***/ "./api/index.js":
/*!**********************!*\
  !*** ./api/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\r\n    videoManager: __webpack_require__(/*! ./classes/VideoManager */ \"./api/classes/VideoManager.js\"),\r\n    subtitleManager: __webpack_require__(/*! ./classes/SubtitleManager */ \"./api/classes/SubtitleManager.js\"),\r\n    mediaPlayerManager: __webpack_require__(/*! ./classes/MediaPlayerManager */ \"./api/classes/MediaPlayerManager.js\"),\r\n    clearSurroundings: __webpack_require__(/*! ./functions/clearSurroundings */ \"./api/functions/clearSurroundings.js\"),\r\n    addKeyListeners: __webpack_require__(/*! ./functions/addKeyListeners */ \"./api/functions/addKeyListeners.js\"),\r\n    registerKeyEvents: __webpack_require__(/*! ./functions/registerKeyEvents */ \"./api/functions/registerKeyEvents.js\"),\r\n    debug: __webpack_require__(/*! ./functions/debug */ \"./api/functions/debug.js\"),\r\n};\r\n\n\n//# sourceURL=webpack://api/./api/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./api/index.js");
/******/ 	api = __webpack_exports__;
/******/ 	
/******/ })()
;